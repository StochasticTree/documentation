"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[824],{2745:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"r-documentation-markdown/calibrate_inverse_gamma_error_variance","title":"calibrate_inverse_gamma_error_variance","description":"Description","source":"@site/docs/r-documentation-markdown/calibrate_inverse_gamma_error_variance.md","sourceDirName":"r-documentation-markdown","slug":"/r-documentation-markdown/calibrate_inverse_gamma_error_variance","permalink":"/documentation/docs/r-documentation-markdown/calibrate_inverse_gamma_error_variance","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/r-documentation-markdown/calibrate_inverse_gamma_error_variance.md","tags":[],"version":"current","frontMatter":{"title":"calibrate_inverse_gamma_error_variance"},"sidebar":"tutorialSidebar","previous":{"title":"bcf","permalink":"/documentation/docs/r-documentation-markdown/bcf"},"next":{"title":"computeForestLeafIndices","permalink":"/documentation/docs/r-documentation-markdown/computeForestLeafIndices"}}');var i=r(4848),t=r(8453);const o={title:"calibrate_inverse_gamma_error_variance"},s="Calibrate the scale parameter on an inverse gamma prior for the global error variance as in Chipman et al (2022)",c={},l=[{value:"Description",id:"description",level:2},{value:"Usage",id:"usage",level:2},{value:"Arguments",id:"arguments",level:2},{value:"Value",id:"value",level:2},{value:"Examples",id:"examples",level:2}];function d(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.header,{children:(0,i.jsx)(a.h1,{id:"calibrate-the-scale-parameter-on-an-inverse-gamma-prior-for-the-global-error-variance-as-in-chipman-et-al-2022",children:"Calibrate the scale parameter on an inverse gamma prior for the global error variance as in Chipman et al (2022)"})}),"\n",(0,i.jsx)(a.h2,{id:"description",children:"Description"}),"\n",(0,i.jsxs)(a.p,{children:[(0,i.jsx)(a.a,{href:"1",children:"1"})," Chipman, H., George, E., Hahn, R., McCulloch, R., Pratola, M. and Sparapani, R. (2022). Bayesian Additive Regression Trees, Computational Approaches. In Wiley StatsRef: Statistics Reference Online (eds N. Balakrishnan, T. Colton, B. Everitt, W. Piegorsch, F. Ruggeri and J.L. Teugels). ",(0,i.jsx)(a.a,{href:"https://doi.org/10.1002/9781118445112.stat08288",children:"https://doi.org/10.1002/9781118445112.stat08288"})]}),"\n",(0,i.jsx)(a.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-r",children:"calibrate_inverse_gamma_error_variance(\n  y,\n  X,\n  W = NULL,\n  nu = 3,\n  quant = 0.9,\n  standardize = TRUE\n)\n"})}),"\n",(0,i.jsx)(a.h2,{id:"arguments",children:"Arguments"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.code,{children:"y"}),": Outcome to be modeled using BART, BCF or another nonparametric ensemble method."]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.code,{children:"X"}),": Covariates to be used to partition trees in an ensemble or series of ensemble."]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.code,{children:"W"}),": ",(0,i.jsx)(a.a,{href:"Optional",children:"Optional"}),' Basis used to define a "leaf regression" model for each decision tree. The "classic" BART model assumes a constant leaf parameter, which is equivalent to a "leaf regression" on a basis of all ones, though it is not necessary to pass a vector of ones, here or to the BART function. Default: ',(0,i.jsx)(a.code,{children:"NULL"}),"."]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.code,{children:"nu"}),": The shape parameter for the global error variance's IG prior. The scale parameter in the Sparapani et al (2021) parameterization is defined as ",(0,i.jsx)(a.code,{children:"nu*lambda"})," where ",(0,i.jsx)(a.code,{children:"lambda"})," is the output of this function. Default: ",(0,i.jsx)(a.code,{children:"3"}),"."]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.code,{children:"quant"}),": ",(0,i.jsx)(a.a,{href:"Optional",children:"Optional"})," Quantile of the inverse gamma prior distribution represented by a linear-regression-based overestimate of ",(0,i.jsx)(a.code,{children:"sigma^2"}),". Default: ",(0,i.jsx)(a.code,{children:"0.9"}),"."]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.code,{children:"standardize"}),": ",(0,i.jsx)(a.a,{href:"Optional",children:"Optional"})," Whether or not outcome should be standardized (",(0,i.jsx)(a.code,{children:"(y-mean(y))/sd(y)"}),") before calibration of ",(0,i.jsx)(a.code,{children:"lambda"}),". Default: ",(0,i.jsx)(a.code,{children:"TRUE"}),"."]}),"\n"]}),"\n",(0,i.jsx)(a.h2,{id:"value",children:"Value"}),"\n",(0,i.jsxs)(a.p,{children:["Value of ",(0,i.jsx)(a.code,{children:"lambda"})," which determines the scale parameter of the global error variance prior (",(0,i.jsx)(a.code,{children:"sigma^2 ~ IG(nu,nu*lambda)"}),")"]}),"\n",(0,i.jsx)(a.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-r",children:"n \\<- 100\np \\<- 5\nX \\<- matrix(runif(n*p), ncol = p)\ny \\<- 10*X[,1] - 20*X[,2] + rnorm(n)\nnu \\<- 3\nlambda \\<- calibrate_inverse_gamma_error_variance(y, X, nu = nu)\nsigma2hat \\<- mean(resid(lm(y~X))^2)\nmean(var(y)/rgamma(100000, nu, rate = nu*lambda) \\< sigma2hat)\n"})})]})}function m(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,a,r)=>{r.d(a,{R:()=>o,x:()=>s});var n=r(6540);const i={},t=n.createContext(i);function o(e){const a=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function s(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(t.Provider,{value:a},e.children)}}}]);