"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[3585],{5784:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"r-documentation-markdown/ForestSamples","title":"ForestSamples","description":"Description","source":"@site/docs/r-documentation-markdown/ForestSamples.md","sourceDirName":"r-documentation-markdown","slug":"/r-documentation-markdown/ForestSamples","permalink":"/documentation/docs/r-documentation-markdown/ForestSamples","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/r-documentation-markdown/ForestSamples.md","tags":[],"version":"current","frontMatter":{"title":"ForestSamples"},"sidebar":"tutorialSidebar","previous":{"title":"ForestModel","permalink":"/documentation/docs/r-documentation-markdown/ForestModel"},"next":{"title":"Outcome","permalink":"/documentation/docs/r-documentation-markdown/Outcome"}}');var t=n(4848),d=n(8453);const l={title:"ForestSamples"},i="Class that stores draws from an random ensemble of decision trees",o={},a=[{value:"Description",id:"description",level:2},{value:"Public fields",id:"public-fields",level:2},{value:"Methods",id:"methods",level:2},{value:"Public methods",id:"public-methods",level:3},{value:"Method <code>new()</code>",id:"method-new",level:3},{value:"Usage",id:"usage",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Returns",id:"returns",level:4},{value:"Method <code>load_from_json()</code>",id:"method-load_from_json",level:3},{value:"Usage",id:"usage-1",level:4},{value:"Arguments",id:"arguments-1",level:4},{value:"Returns",id:"returns-1",level:4},{value:"Method <code>append_from_json()</code>",id:"method-append_from_json",level:3},{value:"Usage",id:"usage-2",level:4},{value:"Arguments",id:"arguments-2",level:4},{value:"Returns",id:"returns-2",level:4},{value:"Method <code>load_from_json_string()</code>",id:"method-load_from_json_string",level:3},{value:"Usage",id:"usage-3",level:4},{value:"Arguments",id:"arguments-3",level:4},{value:"Returns",id:"returns-3",level:4},{value:"Method <code>append_from_json_string()</code>",id:"method-append_from_json_string",level:3},{value:"Usage",id:"usage-4",level:4},{value:"Arguments",id:"arguments-4",level:4},{value:"Returns",id:"returns-4",level:4},{value:"Method <code>predict()</code>",id:"method-predict",level:3},{value:"Usage",id:"usage-5",level:4},{value:"Arguments",id:"arguments-5",level:4},{value:"Returns",id:"returns-5",level:4},{value:"Method <code>predict_raw()</code>",id:"method-predict_raw",level:3},{value:"Usage",id:"usage-6",level:4},{value:"Arguments",id:"arguments-6",level:4},{value:"Returns",id:"returns-6",level:4},{value:"Method <code>predict_raw_single_forest()</code>",id:"method-predict_raw_single_forest",level:3},{value:"Usage",id:"usage-7",level:4},{value:"Arguments",id:"arguments-7",level:4},{value:"Returns",id:"returns-7",level:4},{value:"Method <code>predict_raw_single_tree()</code>",id:"method-predict_raw_single_tree",level:3},{value:"Usage",id:"usage-8",level:4},{value:"Arguments",id:"arguments-8",level:4},{value:"Returns",id:"returns-8",level:4},{value:"Method <code>set_root_leaves()</code>",id:"method-set_root_leaves",level:3},{value:"Usage",id:"usage-9",level:4},{value:"Arguments",id:"arguments-9",level:4},{value:"Method <code>prepare_for_sampler()</code>",id:"method-prepare_for_sampler",level:3},{value:"Usage",id:"usage-10",level:4},{value:"Arguments",id:"arguments-10",level:4},{value:"Method <code>adjust_residual()</code>",id:"method-adjust_residual",level:3},{value:"Usage",id:"usage-11",level:4},{value:"Arguments",id:"arguments-11",level:4},{value:"Method <code>save_json()</code>",id:"method-save_json",level:3},{value:"Usage",id:"usage-12",level:4},{value:"Arguments",id:"arguments-12",level:4},{value:"Method <code>load_json()</code>",id:"method-load_json",level:3},{value:"Usage",id:"usage-13",level:4},{value:"Arguments",id:"arguments-13",level:4},{value:"Method <code>num_samples()</code>",id:"method-num_samples",level:3},{value:"Usage",id:"usage-14",level:4},{value:"Returns",id:"returns-9",level:4},{value:"Method <code>num_trees()</code>",id:"method-num_trees",level:3},{value:"Usage",id:"usage-15",level:4},{value:"Returns",id:"returns-10",level:4},{value:"Method <code>output_dimension()</code>",id:"method-output_dimension",level:3},{value:"Usage",id:"usage-16",level:4},{value:"Returns",id:"returns-11",level:4},{value:"Method <code>add_forest_with_constant_leaves()</code>",id:"method-add_forest_with_constant_leaves",level:3},{value:"Usage",id:"usage-17",level:4},{value:"Arguments",id:"arguments-14",level:4},{value:"Method <code>add_numeric_split_tree()</code>",id:"method-add_numeric_split_tree",level:3},{value:"Usage",id:"usage-18",level:4},{value:"Arguments",id:"arguments-15",level:4},{value:"Method <code>get_tree_leaves()</code>",id:"method-get_tree_leaves",level:3},{value:"Usage",id:"usage-19",level:4},{value:"Arguments",id:"arguments-16",level:4},{value:"Method <code>get_tree_split_counts()</code>",id:"method-get_tree_split_counts",level:3},{value:"Usage",id:"usage-20",level:4},{value:"Arguments",id:"arguments-17",level:4},{value:"Method <code>get_forest_split_counts()</code>",id:"method-get_forest_split_counts",level:3},{value:"Usage",id:"usage-21",level:4},{value:"Arguments",id:"arguments-18",level:4},{value:"Method <code>get_aggregate_split_counts()</code>",id:"method-get_aggregate_split_counts",level:3},{value:"Usage",id:"usage-22",level:4},{value:"Arguments",id:"arguments-19",level:4},{value:"Method <code>get_granular_split_counts()</code>",id:"method-get_granular_split_counts",level:3},{value:"Usage",id:"usage-23",level:4},{value:"Arguments",id:"arguments-20",level:4},{value:"Method <code>ensemble_tree_max_depth()</code>",id:"method-ensemble_tree_max_depth",level:3},{value:"Usage",id:"usage-24",level:4},{value:"Arguments",id:"arguments-21",level:4},{value:"Returns",id:"returns-12",level:4},{value:"Method <code>average_ensemble_max_depth()</code>",id:"method-average_ensemble_max_depth",level:3},{value:"Usage",id:"usage-25",level:4},{value:"Arguments",id:"arguments-22",level:4},{value:"Returns",id:"returns-13",level:4},{value:"Method <code>average_max_depth()</code>",id:"method-average_max_depth",level:3},{value:"Usage",id:"usage-26",level:4},{value:"Returns",id:"returns-14",level:4}];function c(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,d.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"class-that-stores-draws-from-an-random-ensemble-of-decision-trees",children:"Class that stores draws from an random ensemble of decision trees"})}),"\n",(0,t.jsx)(s.h2,{id:"description",children:"Description"}),"\n",(0,t.jsx)(s.p,{children:"Wrapper around a C++ container of tree ensembles"}),"\n",(0,t.jsx)(s.h2,{id:"public-fields",children:"Public fields"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_container_ptr"}),": External pointer to a C++ ForestContainer class"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(s.h3,{id:"public-methods",children:"Public methods"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-new",children:(0,t.jsx)(s.code,{children:"ForestSamples$new()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-load_from_json",children:(0,t.jsx)(s.code,{children:"ForestSamples$load_from_json()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-append_from_json",children:(0,t.jsx)(s.code,{children:"ForestSamples$append_from_json()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-load_from_json_string",children:(0,t.jsx)(s.code,{children:"ForestSamples$load_from_json_string()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-append_from_json_string",children:(0,t.jsx)(s.code,{children:"ForestSamples$append_from_json_string()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-predict",children:(0,t.jsx)(s.code,{children:"ForestSamples$predict()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-predict_raw",children:(0,t.jsx)(s.code,{children:"ForestSamples$predict_raw()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-predict_raw_single_forest",children:(0,t.jsx)(s.code,{children:"ForestSamples$predict_raw_single_forest()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-predict_raw_single_tree",children:(0,t.jsx)(s.code,{children:"ForestSamples$predict_raw_single_tree()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-set_root_leaves",children:(0,t.jsx)(s.code,{children:"ForestSamples$set_root_leaves()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-prepare_for_sampler",children:(0,t.jsx)(s.code,{children:"ForestSamples$prepare_for_sampler()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-adjust_residual",children:(0,t.jsx)(s.code,{children:"ForestSamples$adjust_residual()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-save_json",children:(0,t.jsx)(s.code,{children:"ForestSamples$save_json()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-load_json",children:(0,t.jsx)(s.code,{children:"ForestSamples$load_json()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-num_samples",children:(0,t.jsx)(s.code,{children:"ForestSamples$num_samples()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-num_trees",children:(0,t.jsx)(s.code,{children:"ForestSamples$num_trees()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-output_dimension",children:(0,t.jsx)(s.code,{children:"ForestSamples$output_dimension()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-add_forest_with_constant_leaves",children:(0,t.jsx)(s.code,{children:"ForestSamples$add_forest_with_constant_leaves()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-add_numeric_split_tree",children:(0,t.jsx)(s.code,{children:"ForestSamples$add_numeric_split_tree()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-get_tree_leaves",children:(0,t.jsx)(s.code,{children:"ForestSamples$get_tree_leaves()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-get_tree_split_counts",children:(0,t.jsx)(s.code,{children:"ForestSamples$get_tree_split_counts()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-get_forest_split_counts",children:(0,t.jsx)(s.code,{children:"ForestSamples$get_forest_split_counts()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-get_aggregate_split_counts",children:(0,t.jsx)(s.code,{children:"ForestSamples$get_aggregate_split_counts()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-get_granular_split_counts",children:(0,t.jsx)(s.code,{children:"ForestSamples$get_granular_split_counts()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-ensemble_tree_max_depth",children:(0,t.jsx)(s.code,{children:"ForestSamples$ensemble_tree_max_depth()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-average_ensemble_max_depth",children:(0,t.jsx)(s.code,{children:"ForestSamples$average_ensemble_max_depth()"})})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"#method-ForestSamples-average_max_depth",children:(0,t.jsx)(s.code,{children:"ForestSamples$average_max_depth()"})})}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-new",children:["Method ",(0,t.jsx)(s.code,{children:"new()"})]}),"\n",(0,t.jsx)(s.p,{children:"Create a new ForestContainer object."}),"\n",(0,t.jsx)(s.h4,{id:"usage",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$new(\n  num_trees,\n  output_dimension = 1,\n  is_leaf_constant = F,\n  is_exponentiated = F\n)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"num_trees"}),": Number of trees"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"output_dimension"}),": Dimensionality of the outcome model"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"is_leaf_constant"}),": Whether leaf is constant"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"is_exponentiated"}),": Whether forest predictions should be exponentiated before being returned"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"returns",children:"Returns"}),"\n",(0,t.jsxs)(s.p,{children:["A new ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object."]}),"\n",(0,t.jsxs)(s.h3,{id:"method-load_from_json",children:["Method ",(0,t.jsx)(s.code,{children:"load_from_json()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Create a new ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object from a json object"]}),"\n",(0,t.jsx)(s.h4,{id:"usage-1",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$load_from_json(json_object, json_forest_label)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-1",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"json_object"}),": Object of class ",(0,t.jsx)(s.code,{children:"CppJson"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"json_forest_label"}),': Label referring to a particular forest (i.e. "forest_0") in the overall json hierarchy']}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"returns-1",children:"Returns"}),"\n",(0,t.jsxs)(s.p,{children:["A new ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object."]}),"\n",(0,t.jsxs)(s.h3,{id:"method-append_from_json",children:["Method ",(0,t.jsx)(s.code,{children:"append_from_json()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Append to a ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object from a json object"]}),"\n",(0,t.jsx)(s.h4,{id:"usage-2",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$append_from_json(json_object, json_forest_label)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-2",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"json_object"}),": Object of class ",(0,t.jsx)(s.code,{children:"CppJson"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"json_forest_label"}),': Label referring to a particular forest (i.e. "forest_0") in the overall json hierarchy']}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"returns-2",children:"Returns"}),"\n",(0,t.jsx)(s.p,{children:"NULL"}),"\n",(0,t.jsxs)(s.h3,{id:"method-load_from_json_string",children:["Method ",(0,t.jsx)(s.code,{children:"load_from_json_string()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Create a new ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object from a json object"]}),"\n",(0,t.jsx)(s.h4,{id:"usage-3",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$load_from_json_string(json_string, json_forest_label)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-3",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"json_string"}),": JSON string which parses into object of class ",(0,t.jsx)(s.code,{children:"CppJson"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"json_forest_label"}),': Label referring to a particular forest (i.e. "forest_0") in the overall json hierarchy']}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"returns-3",children:"Returns"}),"\n",(0,t.jsxs)(s.p,{children:["A new ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object."]}),"\n",(0,t.jsxs)(s.h3,{id:"method-append_from_json_string",children:["Method ",(0,t.jsx)(s.code,{children:"append_from_json_string()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Append to a ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object from a json object"]}),"\n",(0,t.jsx)(s.h4,{id:"usage-4",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$append_from_json_string(json_string, json_forest_label)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-4",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"json_string"}),": JSON string which parses into object of class ",(0,t.jsx)(s.code,{children:"CppJson"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"json_forest_label"}),': Label referring to a particular forest (i.e. "forest_0") in the overall json hierarchy']}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"returns-4",children:"Returns"}),"\n",(0,t.jsx)(s.p,{children:"NULL"}),"\n",(0,t.jsxs)(s.h3,{id:"method-predict",children:["Method ",(0,t.jsx)(s.code,{children:"predict()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Predict every tree ensemble on every sample in ",(0,t.jsx)(s.code,{children:"forest_dataset"})]}),"\n",(0,t.jsx)(s.h4,{id:"usage-5",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$predict(forest_dataset)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-5",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_dataset"}),": ",(0,t.jsx)(s.code,{children:"ForestDataset"})," R class"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"returns-5",children:"Returns"}),"\n",(0,t.jsxs)(s.p,{children:["matrix of predictions with as many rows as in forest_dataset\nand as many columns as samples in the ",(0,t.jsx)(s.code,{children:"ForestContainer"})]}),"\n",(0,t.jsxs)(s.h3,{id:"method-predict_raw",children:["Method ",(0,t.jsx)(s.code,{children:"predict_raw()"})]}),"\n",(0,t.jsxs)(s.p,{children:['Predict "raw" leaf values (without being multiplied by basis) for every tree ensemble on every sample in ',(0,t.jsx)(s.code,{children:"forest_dataset"})]}),"\n",(0,t.jsx)(s.h4,{id:"usage-6",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$predict_raw(forest_dataset)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-6",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_dataset"}),": ",(0,t.jsx)(s.code,{children:"ForestDataset"})," R class"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"returns-6",children:"Returns"}),"\n",(0,t.jsxs)(s.p,{children:["Array of predictions for each observation in ",(0,t.jsx)(s.code,{children:"forest_dataset"})," and\neach sample in the ",(0,t.jsx)(s.code,{children:"ForestSamples"})," class with each prediction having the\ndimensionality of the forests' leaf model. In the case of a constant leaf model\nor univariate leaf regression, this array is two-dimensional (number of observations,\nnumber of forest samples). In the case of a multivariate leaf regression,\nthis array is three-dimension (number of observations, leaf model dimension,\nnumber of samples)."]}),"\n",(0,t.jsxs)(s.h3,{id:"method-predict_raw_single_forest",children:["Method ",(0,t.jsx)(s.code,{children:"predict_raw_single_forest()"})]}),"\n",(0,t.jsxs)(s.p,{children:['Predict "raw" leaf values (without being multiplied by basis) for a specific forest on every sample in ',(0,t.jsx)(s.code,{children:"forest_dataset"})]}),"\n",(0,t.jsx)(s.h4,{id:"usage-7",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$predict_raw_single_forest(forest_dataset, forest_num)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-7",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_dataset"}),": ",(0,t.jsx)(s.code,{children:"ForestDataset"})," R class"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_num"}),": Index of the forest sample within the container"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"returns-7",children:"Returns"}),"\n",(0,t.jsxs)(s.p,{children:["matrix of predictions with as many rows as in forest_dataset\nand as many columns as dimensions in the leaves of trees in ",(0,t.jsx)(s.code,{children:"ForestContainer"})]}),"\n",(0,t.jsxs)(s.h3,{id:"method-predict_raw_single_tree",children:["Method ",(0,t.jsx)(s.code,{children:"predict_raw_single_tree()"})]}),"\n",(0,t.jsxs)(s.p,{children:['Predict "raw" leaf values (without being multiplied by basis) for a specific tree in a specific forest on every observation in ',(0,t.jsx)(s.code,{children:"forest_dataset"})]}),"\n",(0,t.jsx)(s.h4,{id:"usage-8",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$predict_raw_single_tree(forest_dataset, forest_num, tree_num)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-8",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_dataset"}),": ",(0,t.jsx)(s.code,{children:"ForestDataset"})," R class"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_num"}),": Index of the forest sample within the container"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"tree_num"}),": Index of the tree to be queried"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"returns-8",children:"Returns"}),"\n",(0,t.jsxs)(s.p,{children:["matrix of predictions with as many rows as in ",(0,t.jsx)(s.code,{children:"forest_dataset"}),"and as many columns as dimensions in the leaves of trees in ",(0,t.jsx)(s.code,{children:"ForestContainer"})]}),"\n",(0,t.jsxs)(s.h3,{id:"method-set_root_leaves",children:["Method ",(0,t.jsx)(s.code,{children:"set_root_leaves()"})]}),"\n",(0,t.jsx)(s.p,{children:"Set a constant predicted value for every tree in the ensemble.\nStops program if any tree is more than a root node."}),"\n",(0,t.jsx)(s.h4,{id:"usage-9",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$set_root_leaves(forest_num, leaf_value)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-9",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_num"}),": Index of the forest sample within the container."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"leaf_value"}),": Constant leaf value(s) to be fixed for each tree in the ensemble indexed by ",(0,t.jsx)(s.code,{children:"forest_num"}),". Can be either a single number or a vector, depending on the forest's leaf dimension."]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-prepare_for_sampler",children:["Method ",(0,t.jsx)(s.code,{children:"prepare_for_sampler()"})]}),"\n",(0,t.jsx)(s.p,{children:"Set a constant predicted value for every tree in the ensemble.\nStops program if any tree is more than a root node."}),"\n",(0,t.jsx)(s.h4,{id:"usage-10",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$prepare_for_sampler(\n  dataset,\n  outcome,\n  forest_model,\n  leaf_model_int,\n  leaf_value\n)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-10",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"dataset"}),": ",(0,t.jsx)(s.code,{children:"ForestDataset"})," Dataset class (covariates, basis, etc...)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"outcome"}),": ",(0,t.jsx)(s.code,{children:"Outcome"})," Outcome class (residual / partial residual)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_model"}),": ",(0,t.jsx)(s.code,{children:"ForestModel"})," object storing tracking structures used in training / sampling"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"leaf_model_int"}),": Integer value encoding the leaf model type (0 = constant gaussian, 1 = univariate gaussian, 2 = multivariate gaussian, 3 = log linear variance)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"leaf_value"}),": Constant leaf value(s) to be fixed for each tree in the ensemble indexed by ",(0,t.jsx)(s.code,{children:"forest_num"}),". Can be either a single number or a vector, depending on the forest's leaf dimension."]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-adjust_residual",children:["Method ",(0,t.jsx)(s.code,{children:"adjust_residual()"})]}),"\n",(0,t.jsx)(s.p,{children:"Adjusts residual based on the predictions of a forest\nThis is typically run just once at the beginning of a forest sampling algorithm.\nAfter trees are initialized with constant root node predictions, their root predictions are subtracted out of the residual."}),"\n",(0,t.jsx)(s.h4,{id:"usage-11",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$adjust_residual(\n  dataset,\n  outcome,\n  forest_model,\n  requires_basis,\n  forest_num,\n  add\n)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-11",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"dataset"}),": ",(0,t.jsx)(s.code,{children:"ForestDataset"})," object storing the covariates and bases for a given forest"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"outcome"}),": ",(0,t.jsx)(s.code,{children:"Outcome"})," object storing the residuals to be updated based on forest predictions"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_model"}),": ",(0,t.jsx)(s.code,{children:"ForestModel"})," object storing tracking structures used in training / sampling"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"requires_basis"}),": Whether or not a forest requires a basis for prediction"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_num"}),": Index of forest used to update residuals"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"add"}),": Whether forest predictions should be added to or subtracted from residuals"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-save_json",children:["Method ",(0,t.jsx)(s.code,{children:"save_json()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Store the trees and metadata of ",(0,t.jsx)(s.code,{children:"ForestDataset"})," class in a json file"]}),"\n",(0,t.jsx)(s.h4,{id:"usage-12",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$save_json(json_filename)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-12",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"json_filename"}),': Name of output json file (must end in ".json")']}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-load_json",children:["Method ",(0,t.jsx)(s.code,{children:"load_json()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Load trees and metadata for an ensemble from a json file. Note that\nany trees and metadata already present in ",(0,t.jsx)(s.code,{children:"ForestDataset"})," class will\nbe overwritten."]}),"\n",(0,t.jsx)(s.h4,{id:"usage-13",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$load_json(json_filename)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-13",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"json_filename"}),': Name of model input json file (must end in ".json")']}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-num_samples",children:["Method ",(0,t.jsx)(s.code,{children:"num_samples()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Return number of samples in a ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object"]}),"\n",(0,t.jsx)(s.h4,{id:"usage-14",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$num_samples()\n"})}),"\n",(0,t.jsx)(s.h4,{id:"returns-9",children:"Returns"}),"\n",(0,t.jsx)(s.p,{children:"Sample count"}),"\n",(0,t.jsxs)(s.h3,{id:"method-num_trees",children:["Method ",(0,t.jsx)(s.code,{children:"num_trees()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Return number of trees in each ensemble of a ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object"]}),"\n",(0,t.jsx)(s.h4,{id:"usage-15",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$num_trees()\n"})}),"\n",(0,t.jsx)(s.h4,{id:"returns-10",children:"Returns"}),"\n",(0,t.jsx)(s.p,{children:"Tree count"}),"\n",(0,t.jsxs)(s.h3,{id:"method-output_dimension",children:["Method ",(0,t.jsx)(s.code,{children:"output_dimension()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Return output dimension of trees in a ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object"]}),"\n",(0,t.jsx)(s.h4,{id:"usage-16",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$output_dimension()\n"})}),"\n",(0,t.jsx)(s.h4,{id:"returns-11",children:"Returns"}),"\n",(0,t.jsx)(s.p,{children:"Leaf node parameter size"}),"\n",(0,t.jsxs)(s.h3,{id:"method-add_forest_with_constant_leaves",children:["Method ",(0,t.jsx)(s.code,{children:"add_forest_with_constant_leaves()"})]}),"\n",(0,t.jsx)(s.p,{children:"Add a new all-root ensemble to the container, with all of the leaves\nset to the value / vector provided"}),"\n",(0,t.jsx)(s.h4,{id:"usage-17",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$add_forest_with_constant_leaves(leaf_value)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-14",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"leaf_value"}),": Value (or vector of values) to initialize root nodes in tree"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-add_numeric_split_tree",children:["Method ",(0,t.jsx)(s.code,{children:"add_numeric_split_tree()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Add a numeric (i.e. X",(0,t.jsx)(s.a,{href:",i",children:",i"})," <= c) split to a given tree in the ensemble"]}),"\n",(0,t.jsx)(s.h4,{id:"usage-18",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$add_numeric_split_tree(\n  forest_num,\n  tree_num,\n  leaf_num,\n  feature_num,\n  split_threshold,\n  left_leaf_value,\n  right_leaf_value\n)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-15",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_num"}),": Index of the forest which contains the tree to be split"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"tree_num"}),": Index of the tree to be split"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"leaf_num"}),": Leaf to be split"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"feature_num"}),": Feature that defines the new split"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"split_threshold"}),": Value that defines the cutoff of the new split"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"left_leaf_value"}),": Value (or vector of values) to assign to the newly created left node"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"right_leaf_value"}),": Value (or vector of values) to assign to the newly created right node"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-get_tree_leaves",children:["Method ",(0,t.jsx)(s.code,{children:"get_tree_leaves()"})]}),"\n",(0,t.jsx)(s.p,{children:"Retrieve a vector of indices of leaf nodes for a given tree in a given forest"}),"\n",(0,t.jsx)(s.h4,{id:"usage-19",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$get_tree_leaves(forest_num, tree_num)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-16",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_num"}),": Index of the forest which contains tree ",(0,t.jsx)(s.code,{children:"tree_num"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"tree_num"}),": Index of the tree for which leaf indices will be retrieved"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-get_tree_split_counts",children:["Method ",(0,t.jsx)(s.code,{children:"get_tree_split_counts()"})]}),"\n",(0,t.jsx)(s.p,{children:"Retrieve a vector of split counts for every training set variable in a given tree in a given forest"}),"\n",(0,t.jsx)(s.h4,{id:"usage-20",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$get_tree_split_counts(forest_num, tree_num, num_features)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-17",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_num"}),": Index of the forest which contains tree ",(0,t.jsx)(s.code,{children:"tree_num"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"tree_num"}),": Index of the tree for which split counts will be retrieved"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"num_features"}),": Total number of features in the training set"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-get_forest_split_counts",children:["Method ",(0,t.jsx)(s.code,{children:"get_forest_split_counts()"})]}),"\n",(0,t.jsx)(s.p,{children:"Retrieve a vector of split counts for every training set variable in a given forest"}),"\n",(0,t.jsx)(s.h4,{id:"usage-21",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$get_forest_split_counts(forest_num, num_features)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-18",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"forest_num"}),": Index of the forest for which split counts will be retrieved"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"num_features"}),": Total number of features in the training set"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-get_aggregate_split_counts",children:["Method ",(0,t.jsx)(s.code,{children:"get_aggregate_split_counts()"})]}),"\n",(0,t.jsx)(s.p,{children:"Retrieve a vector of split counts for every training set variable in a given forest, aggregated across ensembles and trees"}),"\n",(0,t.jsx)(s.h4,{id:"usage-22",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$get_aggregate_split_counts(num_features)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-19",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"num_features"}),": Total number of features in the training set"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-get_granular_split_counts",children:["Method ",(0,t.jsx)(s.code,{children:"get_granular_split_counts()"})]}),"\n",(0,t.jsx)(s.p,{children:"Retrieve a vector of split counts for every training set variable in a given forest, reported separately for each ensemble and tree"}),"\n",(0,t.jsx)(s.h4,{id:"usage-23",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$get_granular_split_counts(num_features)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-20",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"num_features"}),": Total number of features in the training set"]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"method-ensemble_tree_max_depth",children:["Method ",(0,t.jsx)(s.code,{children:"ensemble_tree_max_depth()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Maximum depth of a specific tree in a specific ensemble in a ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object"]}),"\n",(0,t.jsx)(s.h4,{id:"usage-24",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$ensemble_tree_max_depth(ensemble_num, tree_num)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-21",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"ensemble_num"}),": Ensemble number"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"tree_num"}),": Tree index within ensemble ",(0,t.jsx)(s.code,{children:"ensemble_num"})]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"returns-12",children:"Returns"}),"\n",(0,t.jsx)(s.p,{children:"Maximum leaf depth"}),"\n",(0,t.jsxs)(s.h3,{id:"method-average_ensemble_max_depth",children:["Method ",(0,t.jsx)(s.code,{children:"average_ensemble_max_depth()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Average the maximum depth of each tree in a given ensemble in a ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object"]}),"\n",(0,t.jsx)(s.h4,{id:"usage-25",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$average_ensemble_max_depth(ensemble_num)\n"})}),"\n",(0,t.jsx)(s.h4,{id:"arguments-22",children:"Arguments"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"ensemble_num"}),": Ensemble number"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"returns-13",children:"Returns"}),"\n",(0,t.jsx)(s.p,{children:"Average maximum depth"}),"\n",(0,t.jsxs)(s.h3,{id:"method-average_max_depth",children:["Method ",(0,t.jsx)(s.code,{children:"average_max_depth()"})]}),"\n",(0,t.jsxs)(s.p,{children:["Average the maximum depth of each tree in each ensemble in a ",(0,t.jsx)(s.code,{children:"ForestContainer"})," object"]}),"\n",(0,t.jsx)(s.h4,{id:"usage-26",children:"Usage"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"ForestSamples$average_max_depth()\n"})}),"\n",(0,t.jsx)(s.h4,{id:"returns-14",children:"Returns"}),"\n",(0,t.jsx)(s.p,{children:"Average maximum depth"})]})}function h(e={}){const{wrapper:s}={...(0,d.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>i});var r=n(6540);const t={},d=r.createContext(t);function l(e){const s=r.useContext(d);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(d.Provider,{value:s},e.children)}}}]);